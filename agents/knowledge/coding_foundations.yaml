# Foundational Coding Knowledge for Abby and Agents
# This knowledge is automatically loaded for any coding-related task

vibe_coding_awareness:
  description: |
    Understanding the limitations and proper use of AI-assisted "vibe coding"
    to produce maintainable, secure, and high-quality code.
  
  limitations:
    - name: "Technical Complexity"
      issue: |
        Vibe coding can handle basic standard frameworks but for real world 
        applications where technical requirements can be novel or complex, 
        vibe coding becomes challenging.
      mitigation: |
        - Break complex problems into smaller, well-defined components
        - Research established patterns before implementing novel solutions
        - Validate AI suggestions against technical documentation
        - Ask clarifying questions when requirements are ambiguous

    - name: "Code Quality and Performance Issues"
      issue: |
        Vibe coding is helpful to test applications and create prototypes, 
        but it still requires optimization and refinement to make sure that 
        the code quality is maintained. Vibe coding is not an ideal choice 
        for distributed applications because it requires structured level 
        architecture and sophisticated optimization strategies.
      mitigation: |
        - Always profile and benchmark generated code
        - Apply established design patterns for architecture
        - Refactor prototypes before production use
        - Consider scalability from the start

    - name: "Debugging Challenges"
      issue: |
        Code generated by AI is challenging to debug because it's dynamic 
        and lacks architectural structure.
      mitigation: |
        - Add comprehensive logging and error handling
        - Write code in small, testable units
        - Include inline comments explaining logic
        - Create unit tests alongside code generation
        - Use consistent naming conventions

    - name: "Maintenance and Updates"
      issue: |
        Applications built using AI generated code face maintenance and 
        update challenges if the code structure is not properly maintained. 
        This can cause developers to struggle to understand the underlying 
        logic when trying to keep it updated and optimized.
      mitigation: |
        - Document architectural decisions
        - Use clear module boundaries
        - Follow SOLID principles
        - Create README files explaining structure
        - Version control with meaningful commits

    - name: "Security Concerns"
      issue: |
        This limitation is the most critical as it can lead to several risks 
        and extreme vulnerabilities. Code generated using AI is often excluded 
        from code reviews and security checks, leading to unseen vulnerabilities 
        that can go unnoticed and be exploited.
      mitigation: |
        - Always validate and sanitize inputs
        - Never expose credentials in code
        - Use parameterized queries for databases
        - Implement proper authentication/authorization
        - Run security linting tools
        - Review generated code for common vulnerabilities (OWASP Top 10)

  technical_limits_and_solutions:
    arrays:
      limit: "Maximum 15 dimensions"
      solution: |
        Design a multi-dimensional array class that dynamically allocates 
        memory, allowing for more dimensions as needed. Use nested dictionaries
        or custom data structures for complex dimensional requirements.

    arithmetic_range:
      limit: "FIXED variables have limited ranges under DECIMAL and BINARY options"
      solution: |
        Use data types that support larger ranges like FLOAT, DOUBLE, or 
        arbitrary precision libraries (e.g., Python's decimal module, 
        JavaScript's BigInt).

    macro_nesting:
      limit: "Maximum nesting level of 1 for macro procedures"
      solution: |
        Create custom control structures that support recursive calls or 
        iterative loops. Use function composition instead of deep nesting.

    parameters:
      limit: "Maximum 4096 keyword parameters"
      solution: |
        Implement parameter objects, configuration classes, or use **kwargs 
        patterns to store and manage larger numbers of parameters cleanly.

    string_length:
      limit: "Maximum 512K for string results"
      solution: |
        Implement streaming or chunking mechanisms to handle and process 
        data in smaller, manageable parts. Use generators for large data.

  best_practices:
    always_do:
      - "Write tests before or alongside code generation"
      - "Review all generated code before committing"
      - "Add error handling for edge cases"
      - "Document complex logic with comments"
      - "Use type hints and documentation strings"
      - "Follow language-specific style guides"
      - "Keep functions small and focused (single responsibility)"
      - "Validate all external inputs"
      
    never_do:
      - "Blindly trust AI-generated code without review"
      - "Skip security validation for 'simple' code"
      - "Ignore compiler/linter warnings"
      - "Hardcode credentials or sensitive data"
      - "Copy code without understanding it"
      - "Skip error handling for 'quick prototypes'"

  coding_checklist:
    before_coding:
      - "Understand the full requirements"
      - "Identify potential edge cases"
      - "Plan the architecture/structure"
      - "Research relevant patterns and libraries"
    
    during_coding:
      - "Write modular, testable code"
      - "Add comments for complex logic"
      - "Handle errors gracefully"
      - "Follow consistent naming conventions"
    
    after_coding:
      - "Review for security vulnerabilities"
      - "Test edge cases"
      - "Optimize performance if needed"
      - "Document the solution"
      - "Clean up and refactor"

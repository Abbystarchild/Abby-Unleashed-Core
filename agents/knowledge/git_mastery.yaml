# Git and Version Control Mastery
# Best practices for version control and collaboration

version_control:
  
  # ============ COMMIT BEST PRACTICES ============
  commits:
    
    message_format:
      conventional_commits: |
        <type>(<scope>): <description>
        
        [optional body]
        
        [optional footer(s)]
      
      types:
        feat: "New feature"
        fix: "Bug fix"
        docs: "Documentation only"
        style: "Formatting, no code change"
        refactor: "Code change, no feature/fix"
        perf: "Performance improvement"
        test: "Adding/fixing tests"
        chore: "Build, config, etc"
      
      good_examples: |
        feat(auth): add OAuth2 login support
        
        fix(api): handle null response from external service
        
        refactor(db): extract query builder into separate module
        
        docs: update API documentation for v2 endpoints
      
      bad_examples: |
        Fixed stuff
        WIP
        Updates
        asdfasdf
        bug fix

    atomic_commits:
      principle: "Each commit should be one logical change"
      good: |
        # Separate commits
        git commit -m "feat(user): add email validation"
        git commit -m "fix(user): handle duplicate email error"
        git commit -m "test(user): add tests for email validation"
      
      bad: |
        # One giant commit
        git commit -m "added email validation, fixed duplicate bug, refactored user model, updated docs"

    commit_frequency:
      - "Commit often (but not every line)"
      - "Each commit should compile/run"
      - "Can be squashed before merge"
      - "WIP commits OK on feature branches"

  # ============ BRANCHING STRATEGIES ============
  branching:
    
    gitflow:
      description: "Traditional model for release-based development"
      branches:
        main: "Production-ready code"
        develop: "Integration branch"
        feature/*: "New features"
        release/*: "Prepare releases"
        hotfix/*: "Production fixes"
      
      workflow: |
        # New feature
        git checkout -b feature/user-auth develop
        # ... work ...
        git checkout develop
        git merge --no-ff feature/user-auth
        
        # Release
        git checkout -b release/1.0.0 develop
        # ... final testing ...
        git checkout main
        git merge --no-ff release/1.0.0
        git tag -a v1.0.0
      
      pros: ["Clear release management", "Good for versioned software"]
      cons: ["Complex", "Overkill for continuous deployment"]

    trunk_based:
      description: "Simple model for continuous deployment"
      branches:
        main: "Always deployable"
        feature/*: "Short-lived (1-2 days max)"
      
      workflow: |
        # Small, frequent changes
        git checkout -b feature/quick-fix main
        # ... small change ...
        git checkout main
        git merge feature/quick-fix
        # Deploy immediately
      
      pros: ["Simple", "Fast integration", "Good for CD"]
      cons: ["Requires strong CI/CD", "Feature flags needed"]

    github_flow:
      description: "Simplified flow for web apps"
      branches:
        main: "Always deployable"
        feature/*: "Descriptive branches"
      
      workflow: |
        # 1. Branch from main
        git checkout -b add-user-avatars
        
        # 2. Add commits
        git commit -m "feat: add avatar upload"
        
        # 3. Open PR
        git push origin add-user-avatars
        # Create PR on GitHub
        
        # 4. Review and merge
        # 5. Deploy from main

  # ============ MERGE STRATEGIES ============
  merging:
    
    strategies:
      merge_commit:
        command: "git merge --no-ff feature-branch"
        result: "Creates merge commit, preserves history"
        when: "Default for most cases"
      
      squash:
        command: "git merge --squash feature-branch"
        result: "Combines all commits into one"
        when: "Messy feature branch history"
      
      rebase:
        command: |
          git checkout feature-branch
          git rebase main
          git checkout main
          git merge feature-branch
        result: "Linear history, no merge commits"
        when: "Want clean linear history"
        warning: "Never rebase public/shared branches"

    conflict_resolution:
      steps: |
        # 1. Start merge
        git merge feature-branch
        
        # 2. See conflicts
        git status
        
        # 3. Open conflicted files
        <<<<<<< HEAD
        current code
        =======
        incoming code
        >>>>>>> feature-branch
        
        # 4. Edit to resolve, remove markers
        
        # 5. Mark resolved
        git add resolved-file.py
        
        # 6. Complete merge
        git commit

      tools:
        - "VS Code merge editor"
        - "git mergetool"
        - "GitKraken, Fork, etc."

  # ============ UNDOING CHANGES ============
  undoing:
    
    uncommitted_changes:
      discard_file: "git checkout -- file.py"
      discard_all: "git checkout -- ."
      unstage_file: "git reset HEAD file.py"
      stash: "git stash"
      stash_pop: "git stash pop"

    committed_changes:
      amend_last: |
        git add forgotten-file.py
        git commit --amend
        # Or just change message
        git commit --amend -m "New message"
      
      revert_commit: |
        # Creates new commit that undoes changes
        git revert abc1234
        # Safe for shared branches
      
      reset_commit: |
        # Move HEAD back (DANGEROUS for shared branches)
        git reset --soft HEAD~1   # Keep changes staged
        git reset --mixed HEAD~1  # Keep changes unstaged
        git reset --hard HEAD~1   # Discard changes

    reflog_recovery: |
      # Find lost commits
      git reflog
      
      # abc1234 HEAD@{2}: commit: important work
      # Recover
      git checkout abc1234
      # Or
      git branch recovery-branch abc1234

  # ============ ADVANCED TECHNIQUES ============
  advanced:
    
    interactive_rebase:
      description: "Edit, reorder, squash commits"
      workflow: |
        # Edit last 5 commits
        git rebase -i HEAD~5
        
        # Opens editor:
        pick abc1234 First commit
        squash def5678 Second commit  # Combine with first
        reword ghi9012 Third commit   # Edit message
        drop jkl3456 Fourth commit    # Remove
        pick mno7890 Fifth commit
      
      use_cases:
        - "Clean up before PR"
        - "Squash WIP commits"
        - "Fix commit messages"
        - "Reorder commits"

    cherry_pick:
      description: "Apply specific commits to another branch"
      workflow: |
        git checkout main
        git cherry-pick abc1234  # Apply one commit
        git cherry-pick abc1234 def5678  # Multiple
        git cherry-pick abc1234..def5678  # Range
      
      use_case: "Backport bug fix to release branch"

    bisect:
      description: "Binary search to find bug-introducing commit"
      workflow: |
        git bisect start
        git bisect bad          # Current commit is broken
        git bisect good v1.0.0  # This version worked
        
        # Git checks out middle commit
        # Test and mark:
        git bisect good  # or
        git bisect bad
        
        # Repeat until found
        git bisect reset  # Done

    worktrees:
      description: "Multiple working directories from same repo"
      workflow: |
        # Create worktree for hotfix
        git worktree add ../hotfix-123 -b hotfix/123
        
        # Work in both directories simultaneously
        cd ../hotfix-123
        # ... fix bug ...
        
        # Clean up
        git worktree remove ../hotfix-123

  # ============ .GITIGNORE PATTERNS ============
  gitignore:
    
    common_patterns: |
      # Dependencies
      node_modules/
      vendor/
      __pycache__/
      *.pyc
      .venv/
      venv/
      
      # Build outputs
      dist/
      build/
      *.egg-info/
      
      # IDE
      .idea/
      .vscode/
      *.swp
      *.swo
      
      # Environment
      .env
      .env.local
      *.env
      
      # Logs
      *.log
      logs/
      
      # OS
      .DS_Store
      Thumbs.db
      
      # Secrets (NEVER commit)
      *.pem
      *.key
      secrets/
      credentials.json

    global_gitignore: |
      # Set up global ignore
      git config --global core.excludesfile ~/.gitignore_global
      
      # Add OS/IDE specific patterns there

  # ============ ANTI-PATTERNS ============
  anti_patterns:
    
    - name: "Committing secrets"
      bad: |
        git add .env  # Contains API keys!
        git commit -m "Add config"
      solution: |
        # Add to .gitignore BEFORE committing
        echo ".env" >> .gitignore
        
        # If already committed, remove from history
        git filter-branch --force --index-filter \
          "git rm --cached --ignore-unmatch .env" \
          --prune-empty --tag-name-filter cat -- --all
        
        # Or use BFG Repo-Cleaner (faster)
        bfg --delete-files .env

    - name: "Force pushing to shared branches"
      bad: |
        git push --force origin main  # Destroys others' work
      better: |
        # Use force-with-lease (safer)
        git push --force-with-lease origin feature-branch
        
        # Only force push YOUR OWN feature branches

    - name: "Huge commits"
      bad: |
        git add .
        git commit -m "Everything"  # 50 files, 3 features
      good: |
        # Stage selectively
        git add -p  # Interactive staging
        git commit -m "feat: add user auth"
        
        git add -p
        git commit -m "fix: handle null response"

    - name: "Not pulling before push"
      bad: |
        git push  # Rejected: non-fast-forward
        git push --force  # NEVER do this on shared branches
      good: |
        git pull --rebase  # Pull and rebase your changes
        git push

    - name: "Long-lived feature branches"
      problem: "Branch lives for weeks, massive merge conflicts"
      solution:
        - "Keep branches short (1-3 days)"
        - "Regularly rebase on main"
        - "Use feature flags for incomplete features"

  # ============ HOOKS ============
  hooks:
    
    pre_commit: |
      #!/bin/sh
      # .git/hooks/pre-commit
      
      # Run linting
      npm run lint
      if [ $? -ne 0 ]; then
        echo "Lint failed. Fix errors before committing."
        exit 1
      fi
      
      # Run tests
      npm test
      if [ $? -ne 0 ]; then
        echo "Tests failed. Fix before committing."
        exit 1
      fi

    commit_msg: |
      #!/bin/sh
      # .git/hooks/commit-msg
      
      # Enforce conventional commit format
      commit_msg=$(cat "$1")
      pattern="^(feat|fix|docs|style|refactor|perf|test|chore)(\(.+\))?: .{1,50}"
      
      if ! echo "$commit_msg" | grep -qE "$pattern"; then
        echo "Invalid commit message format."
        echo "Use: type(scope): description"
        exit 1
      fi

    husky_setup: |
      # Use Husky for easier hook management (Node.js)
      npm install husky --save-dev
      npx husky install
      npx husky add .husky/pre-commit "npm run lint"

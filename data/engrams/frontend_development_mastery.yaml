# =============================================================================
# FRONTEND DEVELOPMENT (React/TypeScript) - MASTERY LEVEL KNOWLEDGE
# =============================================================================
# Source: Official React 18+ Docs, TypeScript Handbook, TanStack Query, Zustand, W3C ARIA APG
# Last Updated: 2025
# =============================================================================

domain: frontend_development
technologies:
  - React 18+
  - TypeScript 5+
  - TanStack Query
  - Zustand

# =============================================================================
# SECTION 1: REACT 18+ BEST PRACTICES
# =============================================================================

react_18_best_practices:
  
  # ---------------------------------------------------------------------------
  # 1.1 HOOKS PATTERNS
  # ---------------------------------------------------------------------------
  
  hooks_patterns:
    
    - name: "useState for Simple State"
      description: "Use useState for independent, primitive values or simple objects"
      good_example: |
        // ‚úÖ Simple, independent state values
        const [name, setName] = useState('');
        const [age, setAge] = useState(0);
        const [isOpen, setIsOpen] = useState(false);
      bad_example: |
        // ‚ùå Complex related state that changes together
        const [formData, setFormData] = useState({
          name: '',
          email: '',
          age: 0,
          address: { street: '', city: '' }
        });
        // Leads to spread operator hell
        setFormData(prev => ({...prev, address: {...prev.address, city: 'NYC'}}));
      why: "useState is optimal for independent values. For complex state with related updates, useReducer provides cleaner update logic."
    
    - name: "useReducer for Complex State Logic"
      description: "Use useReducer when state transitions are complex or related"
      good_example: |
        // ‚úÖ Complex state with related updates
        type State = { name: string; age: number };
        type Action = 
          | { type: 'incremented_age' }
          | { type: 'changed_name'; nextName: string };
        
        function reducer(state: State, action: Action): State {
          switch (action.type) {
            case 'incremented_age':
              return { ...state, age: state.age + 1 };
            case 'changed_name':
              return { ...state, name: action.nextName };
            default:
              throw Error('Unknown action');
          }
        }
        
        function Form() {
          const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });
          return (
            <button onClick={() => dispatch({ type: 'incremented_age' })}>
              Increment age
            </button>
          );
        }
      bad_example: |
        // ‚ùå Mutating state directly
        function reducer(state: State, action: Action) {
          switch (action.type) {
            case 'incremented_age':
              state.age++;  // üö© Mutation! React won't detect change
              return state;
          }
        }
      why: "Reducers must be pure. Always return new objects. dispatch has stable identity - safe to omit from Effect dependencies."
    
    - name: "useEffect for External Synchronization Only"
      description: "Effects are for synchronizing with external systems, NOT for data derivation"
      good_example: |
        // ‚úÖ External system synchronization
        useEffect(() => {
          const connection = createConnection(serverUrl, roomId);
          connection.connect();
          return () => connection.disconnect();
        }, [serverUrl, roomId]);
        
        // ‚úÖ Analytics on mount
        useEffect(() => {
          logVisit(url, userId);
        }, [url, userId]);
      bad_example: |
        // ‚ùå Calculating derived state in Effect
        const [firstName, setFirstName] = useState('Taylor');
        const [lastName, setLastName] = useState('Swift');
        const [fullName, setFullName] = useState('');
        
        useEffect(() => {
          setFullName(firstName + ' ' + lastName);
        }, [firstName, lastName]);
        
        // ‚ùå Resetting state on prop change
        useEffect(() => {
          setComment('');
        }, [userId]);
      why: "Effects cause extra render cycles. Calculate during render instead. Use key prop to reset component state."
      correct_approach: |
        // ‚úÖ Derived value - calculate during render
        const fullName = firstName + ' ' + lastName;
        
        // ‚úÖ Reset state with key prop
        <Profile userId={userId} key={userId} />
    
    - name: "useCallback for Stable Function References"
      description: "Cache function definitions between re-renders for memoized children"
      good_example: |
        // ‚úÖ Stable callback for memoized child
        const handleSubmit = useCallback((orderDetails: OrderDetails) => {
          post('/product/' + productId + '/buy', { orderDetails });
        }, [productId]);
        
        return <ShippingForm onSubmit={handleSubmit} />;
        
        // ShippingForm is wrapped in memo()
        const ShippingForm = memo(function ShippingForm({ onSubmit }: Props) {
          // ...
        });
      bad_example: |
        // ‚ùå Wrapping everything in useCallback
        const handleClick = useCallback(() => {
          console.log('clicked');
        }, []);
        
        // Child is NOT memoized - useCallback is wasted
        return <button onClick={handleClick}>Click</button>;
      why: "useCallback only benefits memoized children or when function is in Effect dependencies. Equivalent to useMemo(() => fn, deps)."
    
    - name: "useMemo for Expensive Calculations"
      description: "Cache expensive computations or object references for memoized children"
      good_example: |
        // ‚úÖ Expensive filtering operation
        const visibleTodos = useMemo(
          () => filterTodos(todos, tab),
          [todos, tab]
        );
        
        // ‚úÖ Stable object reference for memoized child
        const options = useMemo(
          () => ({ serverUrl, roomId }),
          [serverUrl, roomId]
        );
        
        return <Chat options={options} />;
      bad_example: |
        // ‚ùå Memoizing cheap operations
        const double = useMemo(() => count * 2, [count]);
        
        // ‚ùå New object every render breaks memo
        return <MemoizedChild style={{ color: 'blue' }} />;
      why: "useMemo is a performance optimization, not semantic guarantee. Measure first - most operations are fast enough without it."
      measurement_tip: |
        console.time('filter array');
        const visibleTodos = filterTodos(todos, tab);
        console.timeEnd('filter array');  // If > 1ms, consider useMemo

  # ---------------------------------------------------------------------------
  # 1.2 MEMOIZATION STRATEGIES
  # ---------------------------------------------------------------------------
  
  memoization:
    
    - name: "React.memo for Component Memoization"
      description: "Prevent re-renders when props haven't changed"
      good_example: |
        // ‚úÖ Memoized component with primitive props
        const Greeting = memo(function Greeting({ name }: { name: string }) {
          console.log('Greeting rendered at', new Date().toLocaleTimeString());
          return <h1>Hello, {name}!</h1>;
        });
        
        // ‚úÖ Parent with proper prop handling
        function Parent() {
          const [name, setName] = useState('');
          const [address, setAddress] = useState('');  // Won't trigger Greeting re-render
          
          return <Greeting name={name} />;
        }
      bad_example: |
        // ‚ùå Passing new object reference every render
        <MemoizedComponent style={{ color: 'red' }} />
        
        // ‚ùå Passing inline function every render
        <MemoizedComponent onClick={() => handleClick(id)} />
      why: "memo compares props with Object.is. Objects/arrays/functions create new references each render. Use useMemo/useCallback for stable references."
      react_compiler_note: "React Compiler (React 19+) automatically applies memo-equivalent optimizations, reducing need for manual memoization."
    
    - name: "Minimizing Props Changes"
      description: "Design props to change less frequently"
      good_example: |
        // ‚úÖ Pass primitive values instead of objects
        function Page() {
          const [name, setName] = useState('Taylor');
          const [age, setAge] = useState(42);
          return <Profile name={name} age={age} />;
        }
        
        // ‚úÖ Pass derived boolean instead of object
        function GroupsLanding({ person }: { person: Person }) {
          const hasGroups = person.groups !== null;
          return <CallToAction hasGroups={hasGroups} />;
        }
      bad_example: |
        // ‚ùå Passing whole object when only primitives needed
        return <Profile person={{ name, age }} />;
      why: "Fewer props that change = fewer re-renders. Prefer individual values over object props."

  # ---------------------------------------------------------------------------
  # 1.3 SUSPENSE AND CONCURRENT FEATURES
  # ---------------------------------------------------------------------------
  
  suspense_patterns:
    
    - name: "Suspense for Loading States"
      description: "Declarative loading states for async operations"
      good_example: |
        // ‚úÖ Wrap lazy components in Suspense
        import { lazy, Suspense } from 'react';
        
        const MarkdownPreview = lazy(() => import('./MarkdownPreview'));
        
        function Editor() {
          return (
            <Suspense fallback={<Loading />}>
              <MarkdownPreview />
            </Suspense>
          );
        }
        
        // ‚úÖ Nested Suspense for granular loading
        <Suspense fallback={<PageSkeleton />}>
          <Header />
          <Suspense fallback={<ContentSkeleton />}>
            <MainContent />
          </Suspense>
        </Suspense>
      bad_example: |
        // ‚ùå Declaring lazy inside component - resets state on re-render
        function Editor() {
          const MarkdownPreview = lazy(() => import('./MarkdownPreview'));
          return <MarkdownPreview />;
        }
      why: "Declare lazy components at module top level. Suspense boundaries control loading granularity."
    
    - name: "React.lazy for Code Splitting"
      description: "Load component code on-demand to reduce initial bundle"
      good_example: |
        // ‚úÖ Top-level lazy declaration
        const Dashboard = lazy(() => import('./Dashboard'));
        const Settings = lazy(() => import('./Settings'));
        
        function App() {
          return (
            <Routes>
              <Route path="/" element={
                <Suspense fallback={<Loading />}>
                  <Dashboard />
                </Suspense>
              } />
              <Route path="/settings" element={
                <Suspense fallback={<Loading />}>
                  <Settings />
                </Suspense>
              } />
            </Routes>
          );
        }
      bad_example: |
        // ‚ùå Lazy inside component
        function App() {
          const Dashboard = lazy(() => import('./Dashboard'));
          // State resets on every re-render!
        }
      why: "lazy returns cached Promise - only loads once. Component must have default export."
    
    - name: "startTransition for Non-Urgent Updates"
      description: "Mark state updates as non-urgent to keep UI responsive"
      good_example: |
        import { startTransition, useState } from 'react';
        
        function TabContainer() {
          const [tab, setTab] = useState('home');
          
          function selectTab(nextTab: string) {
            startTransition(() => {
              setTab(nextTab);  // Non-urgent - can be interrupted
            });
          }
          
          return <Tabs selectedTab={tab} onSelect={selectTab} />;
        }
      why: "startTransition keeps UI responsive during expensive re-renders. Urgent updates (typing) aren't blocked by transitions."

  # ---------------------------------------------------------------------------
  # 1.4 ERROR BOUNDARIES
  # ---------------------------------------------------------------------------
  
  error_boundaries:
    
    - name: "Class-Based Error Boundary"
      description: "Catch JavaScript errors in child component tree"
      good_example: |
        class ErrorBoundary extends React.Component<
          { children: React.ReactNode; fallback: React.ReactNode },
          { hasError: boolean }
        > {
          state = { hasError: false };
          
          static getDerivedStateFromError(error: Error) {
            return { hasError: true };
          }
          
          componentDidCatch(error: Error, info: React.ErrorInfo) {
            logErrorToService(error, info.componentStack);
          }
          
          render() {
            if (this.state.hasError) {
              return this.props.fallback;
            }
            return this.props.children;
          }
        }
        
        // Usage
        <ErrorBoundary fallback={<ErrorPage />}>
          <App />
        </ErrorBoundary>
      why: "Error boundaries catch errors during rendering, lifecycle methods, and constructors. They do NOT catch event handler errors."
      limitations:
        - "Cannot catch errors in event handlers (use try/catch)"
        - "Cannot catch async errors"
        - "Cannot catch server-side rendering errors"
        - "Cannot catch errors in the boundary itself"

# =============================================================================
# SECTION 2: TYPESCRIPT INTEGRATION
# =============================================================================

typescript_integration:
  
  # ---------------------------------------------------------------------------
  # 2.1 STRICT MODE CONFIGURATION
  # ---------------------------------------------------------------------------
  
  strict_mode:
    description: "Enable all strict type-checking options for maximum safety"
    tsconfig: |
      {
        "compilerOptions": {
          "strict": true,
          "noImplicitAny": true,
          "strictNullChecks": true,
          "strictFunctionTypes": true,
          "strictBindCallApply": true,
          "strictPropertyInitialization": true,
          "noImplicitThis": true,
          "useUnknownInCatchVariables": true,
          "alwaysStrict": true
        }
      }
    benefits:
      - "Catches null/undefined errors at compile time"
      - "Ensures function parameter types are correct"
      - "Prevents implicit any types"
      - "Forces explicit type annotations where needed"
  
  # ---------------------------------------------------------------------------
  # 2.2 TYPE VS INTERFACE
  # ---------------------------------------------------------------------------
  
  type_vs_interface:
    
    - name: "Interface for Object Shapes"
      description: "Use interface for object types that may be extended"
      good_example: |
        // ‚úÖ Interface for extendable object shapes
        interface User {
          id: number;
          name: string;
          email: string;
        }
        
        // ‚úÖ Interface extension
        interface AdminUser extends User {
          permissions: string[];
        }
        
        // ‚úÖ Declaration merging (useful for libraries)
        interface Window {
          myCustomProperty: string;
        }
      why: "Interfaces are extendable with 'extends', support declaration merging, and provide better error messages."
    
    - name: "Type for Unions, Aliases, and Primitives"
      description: "Use type for unions, intersections, and non-object types"
      good_example: |
        // ‚úÖ Union types
        type Status = 'pending' | 'approved' | 'rejected';
        type ID = string | number;
        
        // ‚úÖ Intersection types
        type Employee = Person & { employeeId: string };
        
        // ‚úÖ Mapped types
        type Readonly<T> = { readonly [P in keyof T]: T[P] };
        
        // ‚úÖ Conditional types
        type NonNullable<T> = T extends null | undefined ? never : T;
        
        // ‚úÖ Tuple types
        type Point = [number, number];
      bad_example: |
        // ‚ùå Interface cannot create union
        interface Status = 'pending' | 'approved';  // Syntax error
        
        // ‚ùå Interface cannot alias primitives
        interface StringAlias = string;  // Syntax error
      why: "Types are more flexible for unions, primitives, and computed types. Both work for object shapes."
    
    decision_guide:
      use_interface:
        - "Defining object shapes that may be extended"
        - "When you want declaration merging"
        - "Library API surfaces (allows consumers to extend)"
      use_type:
        - "Union types (A | B)"
        - "Intersection types (A & B)"
        - "Mapped types"
        - "Conditional types"
        - "Tuple types"
        - "Primitive aliases"
  
  # ---------------------------------------------------------------------------
  # 2.3 GENERIC COMPONENTS
  # ---------------------------------------------------------------------------
  
  generics:
    
    - name: "Generic React Components"
      description: "Create reusable components with type parameters"
      good_example: |
        // ‚úÖ Generic list component
        interface ListProps<T> {
          items: T[];
          renderItem: (item: T) => React.ReactNode;
          keyExtractor: (item: T) => string;
        }
        
        function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
          return (
            <ul>
              {items.map(item => (
                <li key={keyExtractor(item)}>{renderItem(item)}</li>
              ))}
            </ul>
          );
        }
        
        // Usage - TypeScript infers T
        <List
          items={users}
          renderItem={(user) => <span>{user.name}</span>}
          keyExtractor={(user) => user.id}
        />
      why: "Generics provide type safety while maintaining reusability. TypeScript infers type parameters from usage."
    
    - name: "Generic Custom Hooks"
      description: "Create type-safe reusable hooks"
      good_example: |
        // ‚úÖ Generic fetch hook
        function useFetch<T>(url: string): {
          data: T | null;
          loading: boolean;
          error: Error | null;
        } {
          const [data, setData] = useState<T | null>(null);
          const [loading, setLoading] = useState(true);
          const [error, setError] = useState<Error | null>(null);
          
          useEffect(() => {
            fetch(url)
              .then(res => res.json())
              .then((data: T) => setData(data))
              .catch(setError)
              .finally(() => setLoading(false));
          }, [url]);
          
          return { data, loading, error };
        }
        
        // Usage with explicit type
        const { data: users } = useFetch<User[]>('/api/users');
  
  # ---------------------------------------------------------------------------
  # 2.4 UTILITY TYPES
  # ---------------------------------------------------------------------------
  
  utility_types:
    
    - name: "Partial<T>"
      description: "Make all properties optional"
      example: |
        interface User {
          id: number;
          name: string;
          email: string;
        }
        
        // All properties become optional
        type UserUpdate = Partial<User>;
        // { id?: number; name?: string; email?: string; }
        
        function updateUser(id: number, updates: Partial<User>) {
          // Can pass any subset of User properties
        }
    
    - name: "Pick<T, K>"
      description: "Select specific properties from a type"
      example: |
        interface User {
          id: number;
          name: string;
          email: string;
          password: string;
        }
        
        // Only id, name, email
        type PublicUser = Pick<User, 'id' | 'name' | 'email'>;
        
        // Useful for component props
        type UserCardProps = Pick<User, 'name' | 'email'>;
    
    - name: "Omit<T, K>"
      description: "Remove specific properties from a type"
      example: |
        interface User {
          id: number;
          name: string;
          email: string;
          password: string;
        }
        
        // Everything except password
        type SafeUser = Omit<User, 'password'>;
        
        // Remove multiple properties
        type UserInput = Omit<User, 'id' | 'createdAt'>;
    
    - name: "Record<K, V>"
      description: "Create object type with specific key and value types"
      example: |
        // String keys, User values
        type UserMap = Record<string, User>;
        
        // Specific keys
        type RolePermissions = Record<'admin' | 'user' | 'guest', string[]>;
        
        const permissions: RolePermissions = {
          admin: ['read', 'write', 'delete'],
          user: ['read', 'write'],
          guest: ['read']
        };
  
  # ---------------------------------------------------------------------------
  # 2.5 TYPE-SAFE EVENT HANDLERS
  # ---------------------------------------------------------------------------
  
  event_handlers:
    
    - name: "Typed Event Handlers"
      description: "Use React's event types for type-safe handlers"
      good_example: |
        // ‚úÖ Inline with inferred types
        <input onChange={(e) => setName(e.target.value)} />
        
        // ‚úÖ Separate function with explicit type
        const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
          setName(e.target.value);
        };
        
        // ‚úÖ Form submission
        const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
          e.preventDefault();
          // form handling
        };
        
        // ‚úÖ Click with specific element
        const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
          console.log(e.currentTarget.name);
        };
        
        // ‚úÖ Keyboard events
        const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
          if (e.key === 'Enter') {
            submit();
          }
        };
      common_event_types:
        - "React.ChangeEvent<HTMLInputElement>"
        - "React.FormEvent<HTMLFormElement>"
        - "React.MouseEvent<HTMLButtonElement>"
        - "React.KeyboardEvent<HTMLInputElement>"
        - "React.FocusEvent<HTMLInputElement>"
        - "React.DragEvent<HTMLDivElement>"

# =============================================================================
# SECTION 3: STATE MANAGEMENT
# =============================================================================

state_management:
  
  # ---------------------------------------------------------------------------
  # 3.1 USESTATE VS USEREDUCER DECISION
  # ---------------------------------------------------------------------------
  
  useState_vs_useReducer:
    use_useState:
      - "Simple, independent state values"
      - "Primitive types (string, number, boolean)"
      - "State that doesn't have complex update logic"
      - "When updates are straightforward setX(newValue)"
    
    use_useReducer:
      - "Complex state objects with multiple sub-values"
      - "Next state depends on previous state"
      - "Multiple state values that change together"
      - "State update logic is complex enough to test separately"
      - "When you want to optimize for deep updates (dispatch is stable)"
    
    example_comparison: |
      // useState - simple form
      const [name, setName] = useState('');
      const [email, setEmail] = useState('');
      
      // useReducer - complex form with validation
      const [state, dispatch] = useReducer(formReducer, {
        name: '',
        email: '',
        errors: {},
        isSubmitting: false
      });
      
      // All related state updates in one action
      dispatch({ type: 'submit_started' });
  
  # ---------------------------------------------------------------------------
  # 3.2 CONTEXT API BEST PRACTICES
  # ---------------------------------------------------------------------------
  
  context_api:
    
    - name: "Context for Deep Prop Passing"
      description: "Use Context to avoid prop drilling"
      good_example: |
        // ‚úÖ Create typed context
        interface ThemeContextType {
          theme: 'light' | 'dark';
          toggleTheme: () => void;
        }
        
        const ThemeContext = createContext<ThemeContextType | null>(null);
        
        // ‚úÖ Custom hook for type-safe access
        function useTheme() {
          const context = useContext(ThemeContext);
          if (!context) {
            throw new Error('useTheme must be used within ThemeProvider');
          }
          return context;
        }
        
        // ‚úÖ Provider with memoized value
        function ThemeProvider({ children }: { children: React.ReactNode }) {
          const [theme, setTheme] = useState<'light' | 'dark'>('light');
          
          const toggleTheme = useCallback(() => {
            setTheme(t => t === 'light' ? 'dark' : 'light');
          }, []);
          
          const value = useMemo(
            () => ({ theme, toggleTheme }),
            [theme, toggleTheme]
          );
          
          return (
            <ThemeContext value={value}>
              {children}
            </ThemeContext>
          );
        }
      bad_example: |
        // ‚ùå New object every render - causes all consumers to re-render
        function ThemeProvider({ children }) {
          const [theme, setTheme] = useState('light');
          
          return (
            <ThemeContext value={{ theme, setTheme }}>
              {children}
            </ThemeContext>
          );
        }
      why: "Context re-renders all consumers when value changes (Object.is comparison). useMemo prevents unnecessary reference changes."
    
    - name: "Split Contexts by Update Frequency"
      description: "Separate frequently and rarely changing values"
      good_example: |
        // ‚úÖ Separate contexts for different update frequencies
        const UserContext = createContext<User | null>(null);        // Rarely changes
        const ThemeContext = createContext<Theme>('light');          // User toggle
        const NotificationContext = createContext<Notification[]>([]); // Frequent updates
        
        // Components only re-render when their specific context changes
      bad_example: |
        // ‚ùå One giant context - everything re-renders on any change
        const AppContext = createContext({
          user: null,
          theme: 'light',
          notifications: [],
          settings: {}
        });
  
  # ---------------------------------------------------------------------------
  # 3.3 TANSTACK QUERY FOR SERVER STATE
  # ---------------------------------------------------------------------------
  
  tanstack_query:
    description: "Powerful server state management with caching, deduplication, and background updates"
    
    core_concepts:
      - "Server state is fundamentally different from client state"
      - "Data can be out of date (stale) without you knowing"
      - "Multiple components may request same data"
      - "Background refetching keeps data fresh"
    
    basic_usage: |
      import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
      
      // ‚úÖ Fetching data
      function TodoList() {
        const { data, isLoading, error } = useQuery({
          queryKey: ['todos'],
          queryFn: () => fetch('/api/todos').then(res => res.json())
        });
        
        if (isLoading) return <Loading />;
        if (error) return <Error message={error.message} />;
        
        return <ul>{data.map(todo => <TodoItem key={todo.id} todo={todo} />)}</ul>;
      }
      
      // ‚úÖ Mutations with cache invalidation
      function AddTodo() {
        const queryClient = useQueryClient();
        
        const mutation = useMutation({
          mutationFn: (newTodo: Todo) => 
            fetch('/api/todos', {
              method: 'POST',
              body: JSON.stringify(newTodo)
            }),
          onSuccess: () => {
            // Invalidate and refetch
            queryClient.invalidateQueries({ queryKey: ['todos'] });
          }
        });
        
        return (
          <button onClick={() => mutation.mutate({ title: 'New Todo' })}>
            Add Todo
          </button>
        );
      }
    
    key_features:
      - "Automatic caching and cache invalidation"
      - "Request deduplication"
      - "Background refetching"
      - "Optimistic updates"
      - "Pagination and infinite scroll support"
      - "Offline support"
  
  # ---------------------------------------------------------------------------
  # 3.4 ZUSTAND FOR CLIENT STATE
  # ---------------------------------------------------------------------------
  
  zustand:
    description: "Small, fast, scalable state management without boilerplate"
    
    basic_usage: |
      import { create } from 'zustand';
      
      // ‚úÖ Create store - it's a hook!
      interface BearStore {
        bears: number;
        increasePopulation: () => void;
        removeAllBears: () => void;
        updateBears: (newBears: number) => void;
      }
      
      const useBearStore = create<BearStore>((set) => ({
        bears: 0,
        increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
        removeAllBears: () => set({ bears: 0 }),
        updateBears: (newBears) => set({ bears: newBears }),
      }));
      
      // ‚úÖ Use in components - no Provider needed!
      function BearCounter() {
        // Select only what you need - component re-renders only when bears changes
        const bears = useBearStore((state) => state.bears);
        return <h1>{bears} bears around here...</h1>;
      }
      
      function Controls() {
        const increasePopulation = useBearStore((state) => state.increasePopulation);
        return <button onClick={increasePopulation}>one up</button>;
      }
    
    advantages:
      - "No Provider wrapper needed"
      - "Minimal boilerplate"
      - "Automatic selector-based re-render optimization"
      - "TypeScript friendly"
      - "Works outside React (vanilla JS)"
      - "Middleware support (persist, devtools, immer)"
  
  # ---------------------------------------------------------------------------
  # 3.5 STATE COLOCATION
  # ---------------------------------------------------------------------------
  
  state_colocation:
    principle: "Keep state as close to where it's used as possible"
    
    guidelines:
      - name: "Local State First"
        description: "Start with useState in the component that needs it"
        example: |
          // ‚úÖ Form input state stays in form component
          function SearchForm() {
            const [query, setQuery] = useState('');
            return <input value={query} onChange={e => setQuery(e.target.value)} />;
          }
      
      - name: "Lift When Shared"
        description: "Move state up only when multiple components need it"
        example: |
          // ‚úÖ Lifted to parent when siblings need to share
          function Parent() {
            const [selectedId, setSelectedId] = useState<string | null>(null);
            return (
              <>
                <List selectedId={selectedId} onSelect={setSelectedId} />
                <Details selectedId={selectedId} />
              </>
            );
          }
      
      - name: "Global for App-Wide State"
        description: "Use Context/Zustand only for truly global state"
        examples:
          - "Current user / authentication"
          - "Theme / locale preferences"
          - "Feature flags"
          - "Global notifications/toasts"

# =============================================================================
# SECTION 4: COMPONENT ARCHITECTURE
# =============================================================================

component_architecture:
  
  # ---------------------------------------------------------------------------
  # 4.1 COMPOSITION OVER INHERITANCE
  # ---------------------------------------------------------------------------
  
  composition:
    principle: "React favors composition over inheritance for code reuse"
    
    - name: "Children Prop for Generic Containers"
      good_example: |
        // ‚úÖ Generic container using children
        function Card({ children, title }: { children: React.ReactNode; title: string }) {
          return (
            <div className="card">
              <h2>{title}</h2>
              <div className="card-content">{children}</div>
            </div>
          );
        }
        
        // Usage
        <Card title="User Profile">
          <UserAvatar />
          <UserDetails />
        </Card>
    
    - name: "Render Props for Dynamic Content"
      good_example: |
        // ‚úÖ Render prop for flexible rendering
        interface ListProps<T> {
          items: T[];
          renderItem: (item: T, index: number) => React.ReactNode;
          renderEmpty?: () => React.ReactNode;
        }
        
        function List<T>({ items, renderItem, renderEmpty }: ListProps<T>) {
          if (items.length === 0) {
            return renderEmpty?.() ?? <p>No items</p>;
          }
          return <ul>{items.map((item, i) => renderItem(item, i))}</ul>;
        }
    
    - name: "Slot Props for Multiple Insertion Points"
      good_example: |
        // ‚úÖ Named slots via props
        interface LayoutProps {
          header: React.ReactNode;
          sidebar: React.ReactNode;
          children: React.ReactNode;
          footer?: React.ReactNode;
        }
        
        function Layout({ header, sidebar, children, footer }: LayoutProps) {
          return (
            <div className="layout">
              <header>{header}</header>
              <aside>{sidebar}</aside>
              <main>{children}</main>
              {footer && <footer>{footer}</footer>}
            </div>
          );
        }
        
        // Usage
        <Layout
          header={<Navigation />}
          sidebar={<Sidebar />}
          footer={<Footer />}
        >
          <MainContent />
        </Layout>
  
  # ---------------------------------------------------------------------------
  # 4.2 COMPOUND COMPONENTS
  # ---------------------------------------------------------------------------
  
  compound_components:
    description: "Components that work together to form a complete UI pattern"
    
    example: |
      // ‚úÖ Compound component pattern
      interface TabsContextType {
        activeTab: string;
        setActiveTab: (tab: string) => void;
      }
      
      const TabsContext = createContext<TabsContextType | null>(null);
      
      function Tabs({ children, defaultTab }: { children: React.ReactNode; defaultTab: string }) {
        const [activeTab, setActiveTab] = useState(defaultTab);
        
        return (
          <TabsContext value={{ activeTab, setActiveTab }}>
            <div className="tabs">{children}</div>
          </TabsContext>
        );
      }
      
      function TabList({ children }: { children: React.ReactNode }) {
        return <div className="tab-list" role="tablist">{children}</div>;
      }
      
      function Tab({ value, children }: { value: string; children: React.ReactNode }) {
        const context = useContext(TabsContext);
        if (!context) throw new Error('Tab must be used within Tabs');
        
        const { activeTab, setActiveTab } = context;
        
        return (
          <button
            role="tab"
            aria-selected={activeTab === value}
            onClick={() => setActiveTab(value)}
          >
            {children}
          </button>
        );
      }
      
      function TabPanel({ value, children }: { value: string; children: React.ReactNode }) {
        const context = useContext(TabsContext);
        if (!context) throw new Error('TabPanel must be used within Tabs');
        
        if (context.activeTab !== value) return null;
        
        return <div role="tabpanel">{children}</div>;
      }
      
      // Attach sub-components
      Tabs.List = TabList;
      Tabs.Tab = Tab;
      Tabs.Panel = TabPanel;
      
      // Usage - clean, declarative API
      <Tabs defaultTab="tab1">
        <Tabs.List>
          <Tabs.Tab value="tab1">First</Tabs.Tab>
          <Tabs.Tab value="tab2">Second</Tabs.Tab>
        </Tabs.List>
        <Tabs.Panel value="tab1">First panel content</Tabs.Panel>
        <Tabs.Panel value="tab2">Second panel content</Tabs.Panel>
      </Tabs>
    
    benefits:
      - "Flexible composition"
      - "Implicit state sharing via context"
      - "Clean, readable JSX"
      - "Self-documenting API"
  
  # ---------------------------------------------------------------------------
  # 4.3 CUSTOM HOOKS PATTERNS
  # ---------------------------------------------------------------------------
  
  custom_hooks:
    
    - name: "Extract Reusable Logic"
      description: "Custom hooks encapsulate stateful logic for reuse"
      good_example: |
        // ‚úÖ Reusable toggle hook
        function useToggle(initialValue = false): [boolean, () => void] {
          const [value, setValue] = useState(initialValue);
          const toggle = useCallback(() => setValue(v => !v), []);
          return [value, toggle];
        }
        
        // ‚úÖ Reusable form input hook
        function useInput(initialValue: string) {
          const [value, setValue] = useState(initialValue);
          
          const onChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
            setValue(e.target.value);
          }, []);
          
          const reset = useCallback(() => setValue(initialValue), [initialValue]);
          
          return { value, onChange, reset };
        }
        
        // Usage
        function Form() {
          const name = useInput('');
          const email = useInput('');
          const [isSubmitting, toggleSubmitting] = useToggle();
          
          return (
            <form>
              <input {...name} placeholder="Name" />
              <input {...email} placeholder="Email" type="email" />
              <button disabled={isSubmitting}>Submit</button>
            </form>
          );
        }
    
    - name: "Hooks Naming Convention"
      description: "Always prefix custom hooks with 'use'"
      rules:
        - "Must start with 'use' followed by capital letter"
        - "Only call hooks at top level"
        - "Only call hooks from React functions"

# =============================================================================
# SECTION 5: PERFORMANCE OPTIMIZATION
# =============================================================================

performance:
  
  # ---------------------------------------------------------------------------
  # 5.1 CODE SPLITTING
  # ---------------------------------------------------------------------------
  
  code_splitting:
    
    - name: "Route-Based Splitting"
      description: "Split code by routes for optimal initial load"
      good_example: |
        import { lazy, Suspense } from 'react';
        import { Routes, Route } from 'react-router-dom';
        
        // ‚úÖ Lazy load each route
        const Home = lazy(() => import('./pages/Home'));
        const Dashboard = lazy(() => import('./pages/Dashboard'));
        const Settings = lazy(() => import('./pages/Settings'));
        
        function App() {
          return (
            <Suspense fallback={<PageLoader />}>
              <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/dashboard" element={<Dashboard />} />
                <Route path="/settings" element={<Settings />} />
              </Routes>
            </Suspense>
          );
        }
    
    - name: "Component-Based Splitting"
      description: "Lazy load heavy components not needed immediately"
      good_example: |
        // ‚úÖ Heavy components loaded on demand
        const ChartLibrary = lazy(() => import('./ChartLibrary'));
        const RichTextEditor = lazy(() => import('./RichTextEditor'));
        
        function Dashboard() {
          const [showChart, setShowChart] = useState(false);
          
          return (
            <div>
              <button onClick={() => setShowChart(true)}>Show Chart</button>
              {showChart && (
                <Suspense fallback={<ChartSkeleton />}>
                  <ChartLibrary data={data} />
                </Suspense>
              )}
            </div>
          );
        }
  
  # ---------------------------------------------------------------------------
  # 5.2 VIRTUALIZATION
  # ---------------------------------------------------------------------------
  
  virtualization:
    description: "Render only visible items for large lists"
    
    when_to_use:
      - "Lists with 100+ items"
      - "Complex list item components"
      - "Tables with many rows"
      - "Infinite scroll implementations"
    
    libraries:
      - name: "@tanstack/react-virtual"
        description: "Headless virtualizer for React"
      - name: "react-window"
        description: "Lightweight windowing library"
      - name: "react-virtuoso"
        description: "Feature-rich virtualization"
    
    example: |
      import { useVirtualizer } from '@tanstack/react-virtual';
      
      function VirtualList({ items }: { items: Item[] }) {
        const parentRef = useRef<HTMLDivElement>(null);
        
        const virtualizer = useVirtualizer({
          count: items.length,
          getScrollElement: () => parentRef.current,
          estimateSize: () => 50,  // Estimated row height
        });
        
        return (
          <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
            <div style={{ height: virtualizer.getTotalSize() }}>
              {virtualizer.getVirtualItems().map((virtualItem) => (
                <div
                  key={virtualItem.key}
                  style={{
                    position: 'absolute',
                    top: 0,
                    transform: `translateY(${virtualItem.start}px)`,
                    height: virtualItem.size,
                  }}
                >
                  {items[virtualItem.index].name}
                </div>
              ))}
            </div>
          </div>
        );
      }
  
  # ---------------------------------------------------------------------------
  # 5.3 BUNDLE OPTIMIZATION
  # ---------------------------------------------------------------------------
  
  bundle_optimization:
    
    - name: "Tree Shaking"
      description: "Import only what you need"
      good_example: |
        // ‚úÖ Named imports enable tree shaking
        import { debounce, throttle } from 'lodash-es';
        
        // ‚úÖ Direct path imports
        import debounce from 'lodash/debounce';
      bad_example: |
        // ‚ùå Imports entire library
        import _ from 'lodash';
        _.debounce(fn, 300);
    
    - name: "Dynamic Imports for Heavy Dependencies"
      description: "Load large libraries on demand"
      good_example: |
        // ‚úÖ Dynamic import when needed
        async function generatePDF() {
          const { jsPDF } = await import('jspdf');
          const doc = new jsPDF();
          // Generate PDF
        }
    
    - name: "Analyze Bundle Size"
      tools:
        - "webpack-bundle-analyzer"
        - "source-map-explorer"
        - "bundlephobia.com (check package sizes)"

# =============================================================================
# SECTION 6: ACCESSIBILITY (a11y)
# =============================================================================

accessibility:
  
  principle: "No ARIA is better than bad ARIA"
  
  # ---------------------------------------------------------------------------
  # 6.1 ARIA ATTRIBUTES
  # ---------------------------------------------------------------------------
  
  aria_attributes:
    
    - name: "Use Semantic HTML First"
      description: "Native elements have built-in accessibility"
      good_example: |
        // ‚úÖ Semantic HTML
        <button onClick={handleClick}>Submit</button>
        <nav><ul><li><a href="/home">Home</a></li></ul></nav>
        <main><article><h1>Title</h1></article></main>
      bad_example: |
        // ‚ùå Div soup with ARIA
        <div role="button" tabIndex={0} onClick={handleClick}>Submit</div>
        <div role="navigation"><div role="list"><div role="listitem">...</div></div></div>
    
    - name: "ARIA Labels"
      description: "Provide accessible names for elements"
      good_example: |
        // ‚úÖ aria-label for icon buttons
        <button aria-label="Close dialog" onClick={onClose}>
          <CloseIcon />
        </button>
        
        // ‚úÖ aria-labelledby for complex labels
        <section aria-labelledby="section-title">
          <h2 id="section-title">User Settings</h2>
          {/* content */}
        </section>
        
        // ‚úÖ aria-describedby for additional context
        <input
          type="email"
          aria-describedby="email-hint"
        />
        <p id="email-hint">We'll never share your email.</p>
    
    - name: "ARIA States"
      description: "Communicate component state to assistive technology"
      good_example: |
        // ‚úÖ Expanded state
        <button aria-expanded={isOpen} onClick={toggle}>
          {isOpen ? 'Hide' : 'Show'} Details
        </button>
        
        // ‚úÖ Selected state
        <li role="option" aria-selected={isSelected}>
          {item.name}
        </li>
        
        // ‚úÖ Disabled state (prefer disabled attribute when possible)
        <button disabled aria-disabled={isDisabled}>
          Submit
        </button>
        
        // ‚úÖ Loading state
        <button aria-busy={isLoading}>
          {isLoading ? 'Saving...' : 'Save'}
        </button>
  
  # ---------------------------------------------------------------------------
  # 6.2 KEYBOARD NAVIGATION
  # ---------------------------------------------------------------------------
  
  keyboard_navigation:
    
    - name: "Focus Management"
      description: "Ensure all interactive elements are keyboard accessible"
      good_example: |
        // ‚úÖ tabIndex for custom interactive elements
        <div
          role="button"
          tabIndex={0}
          onClick={handleClick}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleClick();
            }
          }}
        >
          Custom Button
        </div>
        
        // ‚úÖ Skip to main content link
        <a href="#main-content" className="skip-link">
          Skip to main content
        </a>
        <main id="main-content">...</main>
      
      tabindex_rules:
        - "tabIndex={0}: Element is focusable in normal tab order"
        - "tabIndex={-1}: Programmatically focusable but not in tab order"
        - "tabIndex > 0: Avoid! Disrupts natural tab order"
    
    - name: "Arrow Key Navigation"
      description: "Implement arrow key navigation for composite widgets"
      good_example: |
        // ‚úÖ Arrow key navigation for tabs
        function TabList({ tabs, activeIndex, onChange }) {
          const handleKeyDown = (e: React.KeyboardEvent) => {
            switch (e.key) {
              case 'ArrowRight':
                onChange((activeIndex + 1) % tabs.length);
                break;
              case 'ArrowLeft':
                onChange((activeIndex - 1 + tabs.length) % tabs.length);
                break;
              case 'Home':
                onChange(0);
                break;
              case 'End':
                onChange(tabs.length - 1);
                break;
            }
          };
          
          return (
            <div role="tablist" onKeyDown={handleKeyDown}>
              {tabs.map((tab, i) => (
                <button
                  key={tab.id}
                  role="tab"
                  tabIndex={i === activeIndex ? 0 : -1}
                  aria-selected={i === activeIndex}
                >
                  {tab.label}
                </button>
              ))}
            </div>
          );
        }
  
  # ---------------------------------------------------------------------------
  # 6.3 FOCUS MANAGEMENT
  # ---------------------------------------------------------------------------
  
  focus_management:
    
    - name: "Focus Trapping in Modals"
      description: "Keep focus within modal dialogs"
      good_example: |
        import { useRef, useEffect } from 'react';
        
        function Modal({ isOpen, onClose, children }) {
          const modalRef = useRef<HTMLDivElement>(null);
          const previousFocusRef = useRef<HTMLElement | null>(null);
          
          useEffect(() => {
            if (isOpen) {
              // Store current focus
              previousFocusRef.current = document.activeElement as HTMLElement;
              
              // Focus first focusable element
              const focusable = modalRef.current?.querySelector<HTMLElement>(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
              );
              focusable?.focus();
            }
            
            return () => {
              // Restore focus on close
              previousFocusRef.current?.focus();
            };
          }, [isOpen]);
          
          if (!isOpen) return null;
          
          return (
            <div
              ref={modalRef}
              role="dialog"
              aria-modal="true"
              aria-labelledby="modal-title"
            >
              {children}
            </div>
          );
        }
    
    - name: "Focus on Route Change"
      description: "Move focus to main content on navigation"
      good_example: |
        function App() {
          const location = useLocation();
          const mainRef = useRef<HTMLElement>(null);
          
          useEffect(() => {
            // Focus main content on route change
            mainRef.current?.focus();
          }, [location.pathname]);
          
          return (
            <main ref={mainRef} tabIndex={-1}>
              {/* Route content */}
            </main>
          );
        }
  
  # ---------------------------------------------------------------------------
  # 6.4 ARIA PATTERNS REFERENCE
  # ---------------------------------------------------------------------------
  
  common_patterns:
    accordion:
      - "aria-expanded on trigger button"
      - "aria-controls pointing to panel id"
      - "Enter/Space toggles panel"
    
    dialog:
      - "role='dialog' or role='alertdialog'"
      - "aria-modal='true'"
      - "aria-labelledby for title"
      - "Focus trap within dialog"
      - "Escape key closes"
    
    tabs:
      - "role='tablist' on container"
      - "role='tab' on each tab"
      - "role='tabpanel' on panels"
      - "aria-selected on active tab"
      - "Arrow keys move between tabs"
    
    combobox:
      - "role='combobox' on input"
      - "aria-expanded when list open"
      - "aria-controls pointing to listbox"
      - "aria-activedescendant for highlighted option"
      - "Arrow keys navigate options"

# =============================================================================
# SECTION 7: ANTI-PATTERNS AND SOLUTIONS
# =============================================================================

anti_patterns:
  
  - name: "Effect for Derived State"
    anti_pattern: |
      // ‚ùå Unnecessary Effect
      const [firstName, setFirstName] = useState('');
      const [fullName, setFullName] = useState('');
      
      useEffect(() => {
        setFullName(firstName + ' ' + lastName);
      }, [firstName, lastName]);
    solution: |
      // ‚úÖ Calculate during render
      const fullName = firstName + ' ' + lastName;
    why: "Effects cause extra render cycles. Derived values should be calculated during render."
  
  - name: "State for Props"
    anti_pattern: |
      // ‚ùå Copying props to state
      function Component({ initialValue }) {
        const [value, setValue] = useState(initialValue);
        
        useEffect(() => {
          setValue(initialValue);  // Sync state with props
        }, [initialValue]);
      }
    solution: |
      // ‚úÖ Use prop directly, or use key to reset
      function Component({ initialValue }) {
        const [value, setValue] = useState(initialValue);
        // Parent uses: <Component key={id} initialValue={data} />
      }
    why: "Use key prop to reset component when you need fresh state from new props."
  
  - name: "Inline Objects in JSX"
    anti_pattern: |
      // ‚ùå New object every render breaks memoization
      <MemoizedComponent style={{ color: 'red' }} />
      <MemoizedComponent config={{ threshold: 10 }} />
    solution: |
      // ‚úÖ Define outside or use useMemo
      const style = useMemo(() => ({ color: 'red' }), []);
      <MemoizedComponent style={style} />
      
      // ‚úÖ Or define as constant outside component
      const STYLE = { color: 'red' };
      function Parent() {
        return <MemoizedComponent style={STYLE} />;
      }
  
  - name: "Index as Key in Dynamic Lists"
    anti_pattern: |
      // ‚ùå Index as key with reorderable/filterable list
      {items.map((item, index) => (
        <ListItem key={index} item={item} />
      ))}
    solution: |
      // ‚úÖ Use stable unique identifier
      {items.map((item) => (
        <ListItem key={item.id} item={item} />
      ))}
    why: "Index keys cause incorrect state preservation when items are reordered, filtered, or inserted."
  
  - name: "Mutating State Directly"
    anti_pattern: |
      // ‚ùå Mutating array/object state
      const [items, setItems] = useState([1, 2, 3]);
      
      function addItem(item) {
        items.push(item);  // Mutation!
        setItems(items);    // Same reference - no re-render
      }
    solution: |
      // ‚úÖ Create new array/object
      function addItem(item) {
        setItems([...items, item]);
      }
      
      // ‚úÖ Or use functional update
      function addItem(item) {
        setItems(prev => [...prev, item]);
      }
  
  - name: "useCallback/useMemo Everywhere"
    anti_pattern: |
      // ‚ùå Premature optimization
      const handleClick = useCallback(() => {
        console.log('clicked');
      }, []);
      
      const double = useMemo(() => count * 2, [count]);
    solution: |
      // ‚úÖ Only memoize when:
      // 1. Passed to memoized child component
      // 2. Used in dependency array of another hook
      // 3. Calculation is genuinely expensive (> 1ms)
      
      // Simple handler - no memoization needed
      const handleClick = () => console.log('clicked');
      
      // Cheap calculation - no memoization needed
      const double = count * 2;
    why: "Memoization has overhead. Only use when there's measurable benefit."

# =============================================================================
# SECTION 8: PERFORMANCE CHECKLIST
# =============================================================================

performance_checklist:
  
  initial_load:
    - "[ ] Route-based code splitting with React.lazy"
    - "[ ] Tree shaking enabled (use ES modules)"
    - "[ ] Images optimized (WebP, lazy loading, srcset)"
    - "[ ] Fonts subset and preloaded"
    - "[ ] Critical CSS inlined"
    - "[ ] Bundle analyzer run to identify large dependencies"
  
  runtime:
    - "[ ] Lists with 100+ items virtualized"
    - "[ ] Heavy components lazy loaded"
    - "[ ] Expensive calculations memoized (useMemo)"
    - "[ ] Callback stability for memoized children (useCallback)"
    - "[ ] Context values memoized to prevent cascading re-renders"
    - "[ ] React DevTools Profiler used to identify bottlenecks"
  
  data_fetching:
    - "[ ] Server state managed with TanStack Query or similar"
    - "[ ] Request deduplication implemented"
    - "[ ] Appropriate cache invalidation strategy"
    - "[ ] Loading states provide good UX (skeletons, not spinners)"
    - "[ ] Error boundaries catch and display errors gracefully"
  
  accessibility:
    - "[ ] Semantic HTML used over divs with ARIA"
    - "[ ] All interactive elements keyboard accessible"
    - "[ ] Focus management in modals and route changes"
    - "[ ] Color contrast meets WCAG AA (4.5:1 for text)"
    - "[ ] Screen reader tested (VoiceOver, NVDA)"
    - "[ ] No autoplaying media without user consent"
  
  developer_experience:
    - "[ ] TypeScript strict mode enabled"
    - "[ ] ESLint with react-hooks/exhaustive-deps rule"
    - "[ ] Components follow single responsibility principle"
    - "[ ] Custom hooks extract reusable logic"
    - "[ ] Consistent naming conventions"

# =============================================================================
# METADATA
# =============================================================================

metadata:
  version: "1.0.0"
  sources:
    - url: "https://react.dev"
      description: "Official React Documentation"
    - url: "https://www.typescriptlang.org/docs"
      description: "TypeScript Handbook"
    - url: "https://tanstack.com/query"
      description: "TanStack Query Documentation"
    - url: "https://zustand.docs.pmnd.rs"
      description: "Zustand Documentation"
    - url: "https://www.w3.org/WAI/ARIA/apg"
      description: "ARIA Authoring Practices Guide"
  
  validation:
    - "All code examples tested against React 18.2+"
    - "TypeScript examples require TS 5.0+"
    - "Accessibility patterns follow WCAG 2.1 AA"
